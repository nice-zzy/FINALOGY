Kline vs Kronos 评估方案总结（可直接作为新对话 Prompt）
一、项目背景
Kline：K 线相似度检索系统，用 52 维手工特征找相似对，训练 CLIP/VICReg 图像编码器做检索。
测试集：6225 对 (anchor, positive)，由 52 维特征相似度 (cosine > 0.85) 构建。
评估指标：Recall@1 / Recall@3、编码器相似度、52 维相似度。
Kronos：金融 K 线基础模型，用 tokenizer + 自回归 Transformer，主要做 OHLC 序列预测。
二、方案一：Kronos 做相似度检索（与 Kline 同任务对比）
目标
在同一个检索任务、同一测试集上，对比 Kronos 与 Kline 的召回表现。
实现思路
取 Kronos embedding
使用 model.decode_s1(s1_ids, s2_ids, stamp, padding_mask) 的第二个返回值 context（hidden states）。
Pooling：取 context[:, -1, :]（last token），与 Kronos 原生预测逻辑一致，不做额外训练或加工。
构造 Kronos 输入
不能用 Kline 的 52 维或图像，需从原始 OHLC 构造。
流程：window_metadata.json → 每个窗口的 (symbol, start_date, end_date) → 从 dow30_real_{symbol}.csv 取出 5 天 OHLC → 得到 (5, 6) 数组 (open, high, low, close, volume, amount)。
列名与 Kronos 要求一致；若无 amount，可填 0 或 volume * close。
数据处理
按 Kronos 要求做 normalize（如 per-series mean/std）和 clip（如 ±5）。
通过 KronosTokenizer.encode() 得到 s1_ids、s2_ids，再送入 model.decode_s1()。
评估流程
对测试集中每个 anchor 和 positive 窗口，用 Kronos 得到 embedding。
对每个 anchor，在候选库中做 KNN（余弦相似度），计算 Recall@1、Recall@3。
用 52 维特征作为外部标准，评估 anchor 与 Kronos 检索结果的形态相似度。
与 Kline 的 Recall@k 和 52 维统计结果对比。
要点
测试集、窗口定义、评估指标与 Kline 完全一致。
使用 Kronos 原生能力，无额外训练或新模块。
输入需从 window_metadata + 原始 CSV 构造 OHLC，不能直接用 52 维或图像。
三、方案二：Kronos 做预测 + 52 维形态评估
目标
评估 Kronos 对未来 K 线形态的预测质量，用 52 维作为形态空间中的度量。
实现思路
预测
输入：历史 OHLC（如 5 天）。
输出：Kronos 预测的未来 N 天 OHLC。
使用 KronosPredictor.predict() 或等价预测接口。
构造测试样本
对每个样本：给定历史 5 天 OHLC，预测未来 5 天 OHLC。
对比：预测的 5 天 OHLC vs 真实未来 5 天 OHLC。
注意：与方案一的 (anchor, positive) 检索测试集不同，需要按「历史窗口 → 未来窗口」构建新的测试集。
52 维形态评估
对「预测的未来 5 天 OHLC」和「真实未来 5 天 OHLC」分别用 Kline 的 OHLCFeatureExtractor 提取 52 维特征。
在 52 维空间计算余弦相似度或欧氏距离，作为形态预测质量指标。
与 Kline 的关系
这是对 Kronos 预测任务的单独评估，不与 Kline 做同任务对比（Kline 不做预测）。
可作为 Kline 检索能力的补充说明：Kline 负责形态检索，Kronos 负责形态预测。
要点
52 维用于衡量「预测形态」与「真实形态」的接近程度。
测试集需新构造（历史→未来），不能直接用 (anchor, positive) 检索测试集。
四、两种方案对比
项目	方案一（检索）	方案二（预测）
任务	相似度检索	未来 OHLC 预测
Kronos 用法	decode_s1 取 embedding + last token pooling	KronosPredictor.predict()
测试集	沿用 Kline 的 (anchor, positive)	新构造（历史→未来）
52 维作用	评估检索结果的形态质量	评估预测 vs 真实形态的相似度
与 Kline 关系	同一任务直接对比	不同任务，作为补充评估
五、实施时需注意
Kronos 依赖：安装 Kronos（含 tokenizer 与模型），从 Hugging Face 或官方仓库获取。
数据构造：需要实现 window_metadata → OHLC 的加载逻辑，并与 Kronos 的 normalize/clip 保持一致。
窗口对齐：Kline 为 5 日窗口，Kronos 输入也为 5 步序列，需保证时间区间一一对应。
pooling：优先使用 last token (context[:, -1, :])，与 Kronos 原生预测设计一致。